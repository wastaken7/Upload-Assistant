name: Python Code Analysis

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
  workflow_dispatch:

permissions:
  contents: read

jobs:
  code-analysis:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.9', '3.10', '3.11', '3.12', '3.13', '3.14']

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        # Install code analysis tools
        pip install mypy bandit vulture pycodestyle autopep8

    - name: Python Syntax Check
      run: |
        echo "Checking Python syntax errors..."
        python -m py_compile $(find . -name "*.py" -not -path "./venv/*" -not -path "./.venv/*" -not -path "./env/*")

    - name: Import Analysis
      run: |
        echo "Checking for import errors..."
        python -c "
        import os
        import sys
        import importlib.util
        
        errors = []
        for root, dirs, files in os.walk('.'):
            # Skip virtual environments and cache directories
            dirs[:] = [d for d in dirs if d not in ['.git', '__pycache__', '.pytest_cache', 'venv', '.venv', 'env']]
            
            for file in files:
                if file.endswith('.py'):
                    filepath = os.path.join(root, file)
                    try:
                        spec = importlib.util.spec_from_file_location('module', filepath)
                        if spec and spec.loader:
                            module = importlib.util.module_from_spec(spec)
                            # Just validate the module can be created, don't execute
                            pass
                    except SyntaxError as e:
                        errors.append(f'Syntax Error in {filepath}: {e}')
                    except Exception as e:
                        errors.append(f'Import Error in {filepath}: {e}')
        
        if errors:
            for error in errors:
                print(error)
            sys.exit(1)
        else:
            print('All Python files have valid syntax and imports')
        "

    - name: Type Checking with MyPy
      continue-on-error: true
      run: |
        echo "Running type checking for Python ${{ matrix.python-version }}..."
        # Override python_version in mypy to match the matrix version
        mypy --config-file mypy.ini --python-version ${{ matrix.python-version }} . > mypy-results-${{ matrix.python-version }}.txt 2>&1 || echo "MyPy scan completed with results saved"
        
        # Display results
        cat mypy-results-${{ matrix.python-version }}.txt

    - name: Upload MyPy Results
      if: github.event_name == 'pull_request'
      uses: actions/upload-artifact@v4
      with:
        name: mypy-results-${{ matrix.python-version }}
        path: mypy-results-${{ matrix.python-version }}.txt

    - name: Security Analysis with Bandit
      continue-on-error: false
      run: |
        echo "Running security analysis with configuration file..."
        echo ""
        echo "üîí SECURITY NOTE: tmp directory security is handled at application level:"
        echo "   ‚úÖ tmp directories created with 0o700 permissions (owner-only access)"
        echo "   ‚úÖ Implemented in upload.py do_the_thing() function"
        echo "   ‚úÖ Bandit B108 warnings suppressed via bandit.yaml config file"
        echo ""
        echo "üìä Using bandit.yaml configuration file to skip resolved security issues"
        
        # Check if bandit.yaml config file exists and use it
        if [ -f "bandit.yaml" ]; then
          echo "‚úÖ Found bandit.yaml configuration file"
          cat bandit.yaml
          echo ""
          echo "Running bandit with YAML configuration..."
          bandit -r . -f txt -c bandit.yaml > bandit-results.txt 2>&1 || echo "Bandit scan completed with configuration"
        elif [ -f ".bandit" ]; then
          echo "‚úÖ Found legacy .bandit configuration file"
          cat .bandit
          echo ""
          echo "Running bandit with legacy configuration..."
          bandit -r . -f txt -c .bandit > bandit-results.txt 2>&1 || echo "Bandit scan completed with configuration"
        else
          echo "‚ö†Ô∏è  No bandit config file found, running with basic exclusions"
          bandit -r . -f txt --exclude ./tmp,./venv,./.venv,./env,./.git,./__pycache__ > bandit-results.txt 2>&1 || echo "Bandit scan completed"
        fi
        
        # Display results
        cat bandit-results.txt

    - name: Upload Bandit Results
      if: github.event_name == 'pull_request'
      uses: actions/upload-artifact@v4
      with:
        name: bandit-results-${{ matrix.python-version }}
        path: bandit-results.txt

    - name: Dependency Security Check with Safety
      continue-on-error: true
      run: |
        echo "Running dependency security check with Safety..."
        pip install safety
        safety check > safety-results.txt 2>&1 || echo "Safety scan completed with results saved"
        
        # Display results
        cat safety-results.txt

    - name: Upload Safety Results
      if: github.event_name == 'pull_request'
      uses: actions/upload-artifact@v4
      with:
        name: safety-results-${{ matrix.python-version }}
        path: safety-results.txt

    - name: Dead Code Analysis
      continue-on-error: false
      run: |
        echo "Checking for unused code..."
        vulture . --exclude=venv,env,.venv,.git --min-confidence=80 > vulture-results.txt 2>&1 || echo "Vulture analysis completed"
        
        # Display results
        cat vulture-results.txt

    - name: Upload Vulture Results
      if: github.event_name == 'pull_request'
      uses: actions/upload-artifact@v4
      with:
        name: vulture-results-${{ matrix.python-version }}
        path: vulture-results.txt

  summary:
    runs-on: ubuntu-latest
    needs: code-analysis
    if: always()
    
    steps:
    - name: Analysis Summary
      run: |
        echo "Python Code Analysis Summary:"
        echo "‚úÖ Syntax checking completed"
        echo "‚úÖ Import validation completed"
        echo "‚úÖ Type checking completed"
        echo "‚úÖ Security analysis with Bandit completed"
        echo "‚úÖ Dependency security check with Safety completed"
        echo "‚úÖ Dead code analysis completed"
        echo "‚úÖ Common issues check completed"
        echo ""
        echo "Check the job logs above for detailed results."

  pr-comment:
    runs-on: ubuntu-latest
    needs: code-analysis
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
      issues: write
      pull-requests: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download Bandit Results
      uses: actions/download-artifact@v4
      with:
        pattern: bandit-results-*
        merge-multiple: true
        
    - name: Download Vulture Results
      uses: actions/download-artifact@v4
      with:
        pattern: vulture-results-*
        merge-multiple: true
        
    - name: Download Safety Results
      uses: actions/download-artifact@v4
      with:
        pattern: safety-results-*
        merge-multiple: true
        
    - name: Download MyPy Results
      uses: actions/download-artifact@v4
      with:
        pattern: mypy-results-*
        merge-multiple: true
        
    - name: Post Bandit Results to PR
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          
          // Check for merged bandit-results.txt file
          const banditFile = 'bandit-results.txt';
          let banditResults = '';
          
          if (fs.existsSync(banditFile)) {
            try {
              banditResults = fs.readFileSync(banditFile, 'utf8');
              console.log('Found merged Bandit results file');
            } catch (error) {
              console.log(`Error reading Bandit file: ${error.message}`);
            }
          } else {
            // Fallback: look for individual result directories
            console.log('Merged Bandit file not found, checking individual directories...');
            const items = fs.readdirSync('.').filter(item => item.startsWith('bandit-results-'));
            
            for (const item of items) {
              try {
                const itemPath = path.join('.', item);
                const stat = fs.statSync(itemPath);
                
                if (stat.isDirectory()) {
                  const filePath = path.join(itemPath, 'bandit-results.txt');
                  if (fs.existsSync(filePath)) {
                    const content = fs.readFileSync(filePath, 'utf8');
                    if (content.trim()) {
                      banditResults += content + '\n\n';
                      console.log(`Found Bandit results in ${item}`);
                    }
                  }
                } else if (stat.isFile() && item.endsWith('.txt')) {
                  const content = fs.readFileSync(itemPath, 'utf8');
                  if (content.trim()) {
                    banditResults += content + '\n\n';
                    console.log(`Found Bandit results in ${item}`);
                  }
                }
              } catch (error) {
                console.log(`Error reading Bandit ${item}: ${error.message}`);
              }
            }
          }
          
          // Check for merged vulture-results.txt file
          const vultureFile = 'vulture-results.txt';
          let vultureResults = '';
          
          if (fs.existsSync(vultureFile)) {
            try {
              vultureResults = fs.readFileSync(vultureFile, 'utf8');
              console.log('Found merged Vulture results file');
            } catch (error) {
              console.log(`Error reading Vulture file: ${error.message}`);
            }
          } else {
            // Fallback: look for individual result directories
            console.log('Merged Vulture file not found, checking individual directories...');
            const items = fs.readdirSync('.').filter(item => item.startsWith('vulture-results-'));
            
            for (const item of items) {
              try {
                const itemPath = path.join('.', item);
                const stat = fs.statSync(itemPath);
                
                if (stat.isDirectory()) {
                  const filePath = path.join(itemPath, 'vulture-results.txt');
                  if (fs.existsSync(filePath)) {
                    const content = fs.readFileSync(filePath, 'utf8');
                    if (content.trim()) {
                      vultureResults += content + '\n\n';
                      console.log(`Found Vulture results in ${item}`);
                    }
                  }
                } else if (stat.isFile() && item.endsWith('.txt')) {
                  const content = fs.readFileSync(itemPath, 'utf8');
                  if (content.trim()) {
                    vultureResults += content + '\n\n';
                    console.log(`Found Vulture results in ${item}`);
                  }
                }
              } catch (error) {
                console.log(`Error reading Vulture ${item}: ${error.message}`);
              }
            }
          }
          
          // Check for merged safety-results.txt file
          const safetyFile = 'safety-results.txt';
          let safetyResults = '';
          
          if (fs.existsSync(safetyFile)) {
            try {
              safetyResults = fs.readFileSync(safetyFile, 'utf8');
              console.log('Found merged Safety results file');
            } catch (error) {
              console.log(`Error reading Safety file: ${error.message}`);
            }
          } else {
            // Fallback: look for individual result directories
            console.log('Merged Safety file not found, checking individual directories...');
            const items = fs.readdirSync('.').filter(item => item.startsWith('safety-results-'));
            
            for (const item of items) {
              try {
                const itemPath = path.join('.', item);
                const stat = fs.statSync(itemPath);
                
                if (stat.isDirectory()) {
                  const filePath = path.join(itemPath, 'safety-results.txt');
                  if (fs.existsSync(filePath)) {
                    const content = fs.readFileSync(filePath, 'utf8');
                    if (content.trim()) {
                      safetyResults += content + '\n\n';
                      console.log(`Found Safety results in ${item}`);
                    }
                  }
                } else if (stat.isFile() && item.endsWith('.txt')) {
                  const content = fs.readFileSync(itemPath, 'utf8');
                  if (content.trim()) {
                    safetyResults += content + '\n\n';
                    console.log(`Found Safety results in ${item}`);
                  }
                }
              } catch (error) {
                console.log(`Error reading Safety ${item}: ${error.message}`);
              }
            }
          }
          
          // Check for mypy results files (one per Python version)
          // Collect results per version, then deduplicate identical outputs
          let mypyResults = '';
          const mypyFiles = fs.readdirSync('.').filter(f => f.startsWith('mypy-results-') && f.endsWith('.txt'));
          
          // Map: content -> [versions]
          const mypyByContent = new Map();
          
          if (mypyFiles.length > 0) {
            for (const file of mypyFiles) {
              try {
                const content = fs.readFileSync(file, 'utf8').trim();
                if (content) {
                  // Extract version from filename (e.g., mypy-results-3.9.txt -> 3.9)
                  const version = file.replace('mypy-results-', '').replace('.txt', '');
                  if (!mypyByContent.has(content)) {
                    mypyByContent.set(content, []);
                  }
                  mypyByContent.get(content).push(version);
                  console.log(`Found MyPy results for Python ${version}`);
                }
              } catch (error) {
                console.log(`Error reading ${file}: ${error.message}`);
              }
            }
          } else {
            // Fallback: look for individual result directories
            console.log('No MyPy result files found, checking individual directories...');
            const items = fs.readdirSync('.').filter(item => item.startsWith('mypy-results-'));
            
            for (const item of items) {
              try {
                const itemPath = path.join('.', item);
                const stat = fs.statSync(itemPath);
                
                if (stat.isDirectory()) {
                  const dirFiles = fs.readdirSync(itemPath).filter(f => f.endsWith('.txt'));
                  for (const file of dirFiles) {
                    const filePath = path.join(itemPath, file);
                    const content = fs.readFileSync(filePath, 'utf8').trim();
                    if (content) {
                      const version = item.replace('mypy-results-', '');
                      if (!mypyByContent.has(content)) {
                        mypyByContent.set(content, []);
                      }
                      mypyByContent.get(content).push(version);
                      console.log(`Found MyPy results in ${item}/${file}`);
                    }
                  }
                }
              } catch (error) {
                console.log(`Error reading MyPy ${item}: ${error.message}`);
              }
            }
          }
          
          // Build deduplicated mypy output
          for (const [content, versions] of mypyByContent.entries()) {
            // Sort versions for consistent display
            versions.sort((a, b) => parseFloat(a) - parseFloat(b));
            if (versions.length === 1) {
              mypyResults += `=== Python ${versions[0]} ===\n${content}\n\n`;
            } else {
              mypyResults += `=== Python ${versions.join(', ')} (identical results) ===\n${content}\n\n`;
            }
          }
          
          banditResults = banditResults.trim();
          vultureResults = vultureResults.trim();
          safetyResults = safetyResults.trim();
          mypyResults = mypyResults.trim();
          
          // Filter out manager warnings about test comments from Bandit results
          let cleanBanditResults = '';
          if (banditResults) {
            const lines = banditResults.split('\n');
            const filteredLines = lines.filter(line => !line.includes('[manager]\tWARNING\tTest in comment'));
            cleanBanditResults = filteredLines.join('\n').trim();
          }
          
          // Check if we have any issues to report
          const hasBanditIssues = cleanBanditResults && cleanBanditResults.includes('Issue: [');
          const hasVultureIssues = vultureResults && vultureResults.includes('(100% confidence)');
          const hasSafetyIssues = safetyResults && safetyResults.includes('Dependency vulnerabilities detected:');
          const hasMyPyIssues = mypyResults && !mypyResults.includes('Success: no issues found') && mypyResults.trim() !== '';
          
          if (!hasBanditIssues && !hasVultureIssues && !hasSafetyIssues && !hasMyPyIssues) {
            console.log('No security, dead code, dependency, or type issues found, skipping PR comment.');
            return;
          }
          
          // Build the comment body
          let body = '## üîç Code Analysis Results\n\n';
          
          if (hasMyPyIssues) {
            body += '### üîç MyPy Type Checking\n\n```\n' + mypyResults + '\n```\n\n';
          }
          
          if (hasBanditIssues) {
            body += '### üîí Bandit Security Analysis\n\n```\n' + cleanBanditResults + '\n```\n\n';
          }
          
          if (hasVultureIssues) {
            body += '### üßπ Dead Code Analysis (Vulture)\n\n```\n' + vultureResults + '\n```\n\n';
          }
          
          if (hasSafetyIssues) {
            body += '### üì¶ Dependency Security Analysis (Safety)\n\n```\n' + safetyResults + '\n```\n\n';
          }
          
          body += '*This comment was automatically generated by the CI pipeline.*';
          
          try {
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
            console.log('Successfully posted code analysis results to PR');
          } catch (error) {
            console.error(`Failed to post PR comment: ${error.message}`);
            throw error;
          }